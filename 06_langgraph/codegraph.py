# flake8: noqa

from typing_extensions import TypedDict
from langgraph.graph import StateGraph,START,END
from dotenv import load_dotenv
from openai import OpenAI
from pydantic import BaseModel
from typing import Literal
import json
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import os
load_dotenv()
# use the openai module (reads OPENAI_API_KEY from env via load_dotenv)
client = OpenAI()

class State(TypedDict):
    user_query:str
    llm_result:str | None
    accuracy_percentage: str | None
    is_coding_question: bool | None
    is_email_question:bool | None
    count:int
    email:str | None
    subject:str | None
    body:str | None


class ClassifyMessageResponse(BaseModel):
    is_coding_question:bool
    is_email_question:bool

class CodeAccuracyResponse(BaseModel):
    accuracy_percentage:str

def classifyMessage(state:State):

    print("ðŸ¤– Classifying Message")
    query=state['user_query']
    SYSTEM_PROMPT="""You are an AI assistant. Your job is to detect if the user's query is related to coding question or email question or just a general query.
    Return the response in the specified JSON boolean only.
    """

    response=client.chat.completions.parse(
        model="gpt-4.1-nano",
        messages=[
            {"role":"system","content":SYSTEM_PROMPT},
            {"role":"user","content":query}
        ],
        response_format=ClassifyMessageResponse
    )
    question = response.choices[0].message.parsed
    is_email_question=question.is_email_question
    is_coding_question=question.is_coding_question
    state["is_coding_question"] = is_coding_question
    state["is_email_question"]=is_email_question
    print(is_coding_question)
    print(is_email_question)
    return state

def route_query(state:State) -> Literal["general_query","coding_query","email_query"]:
    print("ðŸ¤– routing query -->>")
    is_coding=state["is_coding_question"]
    is_email=state["is_email_question"]
    print(is_coding , "here")
    print(is_email, "here")
    if is_coding:
        return "coding_query"
    elif is_email:
        return "email_query"
    return "general_query"

def general_query(state:State):
    print("ðŸ¤– running general query")
    query=state["user_query"]
    response=client.chat.completions.create(
        model="gpt-4.1-mini",
        messages=[
            {"role":"user","content":query}
        ]
    )
    state["llm_result"]=response.choices[0].message.content
    return state

def coding_query(state:State):

    print("ðŸ¤– running coding query")

    query=state["user_query"]
    response=client.chat.completions.create(
        model="gpt-4.1",
        messages=[
            {"role":"user","content":query}
        ]
    )
    state["llm_result"]=response.choices[0].message.content
    state["count"]=state["count"]+1

    return state


def email_query(state:State):
    print("Email Query")

    query = state["user_query"]

    # Step 1 â€” Extract details from user query
    extraction_prompt = f"""You are an email extraction agent.
    Extract the following from the user's query:
    1. Receiver email address
    2. Subject of email
    3. The intent / purpose of the email

    User query: ${query}

    Return STRICT JSON with keys:
    {{
        "email": "",
        "subject": "",
        "purpose": ""
    }}
    """

    extract = client.chat.completions.create(
        model="gpt-4.1",
        messages=[{"role": "user", "content": extraction_prompt}],
        temperature=0
    )

    extracted = json.loads(extract.choices[0].message.content)

    receiver = extracted["email"]
    subject = extracted["subject"]
    purpose = extracted["purpose"]


    EMAIL_FORMAT = f"""
You are an AI email writing assistant. Generate ONLY the body of the email.
Do NOT generate greetings like "Hi", "Hello", "Dear" at the beginning.
Do NOT generate the subject.
Do NOT generate closing phrases except the required final signature format.
Do NOT add bold formatting or any special font styles.

Email Requirements:
1. The email body must begin immediately without salutations.
2. Do not bold, highlight, or style any word.
3. Maintain a polite, clear, professional tone.
4. The sender's email is: vikrams131204@gmail.com
5. End every email EXACTLY with:

Best regards
Vikram Shrivastav

Here is a reference structure of the email body:

[content generated by AI]

Best regards
Vikram Shrivastav

Example Output:
I wanted to follow up regarding the project timeline and request an update on the current progress. Please let me know if there are any blockers or if I can assist you with anything.

Best regards
Vikram Shrivastav
"""

    # Step 2 â€” Generate full email body
    email_gen_prompt = f"""
    Write a professional email based on this purpose:
    "{purpose}"
    Follow this email format only for writing this email:${EMAIL_FORMAT}
    The email should be:
    - polite
    - clearly formatted
    - in plain text
    """

    email_body_response = client.chat.completions.create(
        model="gpt-4.1",
        messages=[{"role": "user", "content": email_gen_prompt}],
        temperature=0.4
    )

    body = email_body_response.choices[0].message.content

    # Step 4 â€” Save to state
    state["email"] = receiver
    state["subject"] = subject
    state["body"] = body

    return state

def coding_validate_query(state:State):
    print("ðŸ¤– validating code")
    query=state["user_query"]
    llm_code=state["llm_result"]
    SYSTEM_PROMPT=f"""You are an expert AI assistant in analyzing and calculating the accuracy of the code according to the question. Return the percentage of accuracy 
    User Query :{query}
    Code: {llm_code}
    """
    response=client.chat.completions.parse(
        model="gpt-4.1-nano",
        messages=[
            {"role":"system","content":SYSTEM_PROMPT},
            {"role":"user","content":query}
        ],
        response_format=CodeAccuracyResponse
    )
    state["accuracy_percentage"]=response.choices[0].message.parsed.accuracy_percentage
    return state


def checkpercentage(state: State) -> Literal["coding_query", END]:
    accuracy_percentage = state["accuracy_percentage"]

    # convert "92%" â†’ 92.0
    accuracy = float(accuracy_percentage.replace("%", ""))

    if accuracy < 95:
        curr_count=state["count"]
        if curr_count >=2:
            return END
        print("ðŸ” Accuracy below threshold, retrying...")
        return "coding_query"
    return END


def email_sender(state:State):
    email=state["email"] 
    body=state["body"]
    subject=state["subject"]
    sender_email = "vikrams131204@gmail.com"
    sender_pass = "kugvzjnvdwbbhzwc"

    msg = MIMEMultipart()
    msg["From"] = sender_email
    msg["To"] = email
    msg["Subject"] = subject

    msg.attach(MIMEText(body, "plain"))

    try:
        server = smtplib.SMTP("smtp.gmail.com", 587)
        server.starttls()
        server.login(sender_email, sender_pass)
        server.sendmail(sender_email, email, msg.as_string())
        server.quit()

        print("ðŸ“§ Email sent successfully! to: ",email)
        return state

    except Exception as e:
        print("âŒ Email sending failed:", e)
        return state


graph_builder=StateGraph(State)
graph_builder.add_node("classifyMessage",classifyMessage)
graph_builder.add_node("route_query",route_query)
graph_builder.add_node("general_query",general_query)
graph_builder.add_node("coding_query",coding_query)
graph_builder.add_node("coding_validate_query",coding_validate_query)
graph_builder.add_node("checkpercentage",checkpercentage)
graph_builder.add_node("email_query",email_query)
graph_builder.add_node("email_sender",email_sender)

graph_builder.add_edge(START,"classifyMessage")
graph_builder.add_conditional_edges("classifyMessage",route_query)
graph_builder.add_edge("general_query",END)
graph_builder.add_edge("email_query","email_sender")
graph_builder.add_edge("email_sender",END)
graph_builder.add_edge("coding_query","coding_validate_query")
graph_builder.add_conditional_edges("coding_validate_query",checkpercentage)
graph_builder.add_edge("coding_query","coding_validate_query")
graph_builder.add_edge("coding_validate_query",END)
graph=graph_builder.compile()

def main():
    user=input(">")
    _state:State={
        "user_query":user,
        "is_coding_question":False,
        "is_email_question":False,
        "accuracy_percentage":None,
        "llm_result":None,
        "count":0,
        "email":None,
        "subject":None,
        "body":None

    }
    for event in graph.stream(_state):
        print("Event",event)

main()